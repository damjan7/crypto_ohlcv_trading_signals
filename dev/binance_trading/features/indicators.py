from typing import List, Dict, Any, Optional
import pandas as pd
import numpy as np
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class Config:
    """
    Configuration for technical feature calculations.
    """
    lookback_period_rsi: int = 14
    lookback_period_bollinger: int = 20
    rsi_oversold: float = 30
    rsi_overbought: float = 70
    ema_short: int = 9
    ema_long: int = 21
    stochastic_period: int = 14
    atr_period: int = 14

class BaseFeature(ABC):
    """
    Abstract base class for feature calculation classes.
    """
    @abstractmethod
    def get_names(self) -> List[str]:
        """Return the names of the features generated by this class."""
        pass

    @abstractmethod
    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calculate and add features to the DataFrame."""
        pass

class RSIFeature(BaseFeature):
    def __init__(self, config: Config):
        self.period = config.lookback_period_rsi
        self.oversold = config.rsi_oversold
        self.overbought = config.rsi_overbought
    
    def get_names(self) -> List[str]:
        return ['RSI', 'RSI_feature']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=self.period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.period).mean()
        rs = gain / loss
        df['RSI'] = 100 - (100 / (1 + rs))
        df['RSI_feature'] = np.where(df['RSI'] < self.oversold, 1, 
                                     np.where(df['RSI'] > self.overbought, -1, 0))
        return df

class EMAFeature(BaseFeature):
    def __init__(self, config: Config):
        self.short_period = config.ema_short
        self.long_period = config.ema_long

    def get_names(self) -> List[str]:
        return ['EMA_short', 'EMA_long', 'EMA_feature']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        df['EMA_short'] = df['close'].ewm(span=self.short_period, adjust=False).mean()
        df['EMA_long'] = df['close'].ewm(span=self.long_period, adjust=False).mean()
        df['EMA_feature'] = np.where(df['EMA_short'] > df['EMA_long'], 1, -1)
        return df
    
class ReturnFeatures(BaseFeature):
    def __init__(self):
        self.periods = {'1': 1, '2': 2, '6': 6, '12': 12}

    def get_names(self) -> List[str]:
        return [f'return_{name}' for name in self.periods.keys()]

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        for name, period in self.periods.items():
            df[f'return_{name}'] = df['close'].pct_change(periods=period)
        return df

class VolatilityFeatures(BaseFeature):
    def __init__(self):
        self.windows = [2, 6, 12, 24, 48]

    def get_names(self) -> List[str]:
        return [f'volatility_{window}' for window in self.windows]

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        for window in self.windows:
            df[f'volatility_{window}'] = df['close'].pct_change().rolling(window=window).std()
        return df

class VolumeFeatures(BaseFeature):
    def __init__(self):
        self.windows = [2, 6, 12, 24, 48]

    def get_names(self) -> List[str]:
        return [f'volume_ma_{window}' for window in self.windows] + ['volume_rel_ma24']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        if 'usd_volume' not in df.columns and 'volume' in df.columns:
             # Fallback if usd_volume is missing but volume exists, though original code used usd_volume
             pass 
        # Assuming inputs will have usd_volume or we rename it before calling this.
        # But let's check what binance-historical-data returns. Usually Open, High, Low, Close, Volume.
        # We might need to compute usd_volume = volume * close or similar, or just use volume.
        # For now, I will assume column 'usd_volume' exists or we create it in pipeline.
        
        for window in self.windows:
            if 'usd_volume' in df.columns:
                df[f'volume_ma_{window}'] = df['usd_volume'].rolling(window=window).mean()
        
        if 'usd_volume' in df.columns:
            df['volume_rel_ma24'] = df['usd_volume'] / df['volume_ma_24']
        return df

class PriceMAFeatures(BaseFeature):
    def __init__(self):
        self.windows = [2, 6, 12, 24, 48, 96]
    
    def get_names(self) -> List[str]:
        return [f'price_ma_{window}' for window in self.windows] + [f'price_rel_ma_{window}' for window in self.windows]

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        for window in self.windows:
            df[f'price_ma_{window}'] = df['close'].rolling(window=window).mean()
            df[f'price_rel_ma_{window}'] = df['close'] / df[f'price_ma_{window}'] - 1
        return df

class MomentumFeatures(BaseFeature):
    def __init__(self):
        self.windows = [2, 6, 12, 24, 48]
    
    def get_names(self) -> List[str]:
        return [f'momentum_{window}' for window in self.windows] + ['macd', 'macd_feature']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        for window in self.windows:
            df[f'momentum_{window}'] = df['close'].pct_change(periods=window)
        
        df['ema_12'] = df['close'].ewm(span=12, adjust=False).mean()
        df['ema_26'] = df['close'].ewm(span=26, adjust=False).mean()
        df['macd'] = df['ema_12'] - df['ema_26']
        df['macd_feature'] = df['macd'].ewm(span=9, adjust=False).mean()
        return df

class BollingerBandsFeature(BaseFeature):
    def __init__(self, config: Config):
        self.period = config.lookback_period_bollinger
        self.std_dev = 2
    
    def get_names(self) -> List[str]:
        return ['BB_middle', 'BB_upper', 'BB_lower', 'BB_feature']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        df['BB_middle'] = df['close'].rolling(window=self.period).mean()
        df['BB_std'] = df['close'].rolling(window=self.period).std()
        df['BB_upper'] = df['BB_middle'] + (df['BB_std'] * self.std_dev)
        df['BB_lower'] = df['BB_middle'] - (df['BB_std'] * self.std_dev)
        df['BB_feature'] = np.where(df['close'] < df['BB_lower'], 1,
                                     np.where(df['close'] > df['BB_upper'], -1, 0))
        return df

class ATRFeature(BaseFeature):
    def __init__(self, config: Config):
        self.period = config.atr_period

    def get_names(self) -> List[str]:
        return ['ATR']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        high_low = df['high'] - df['low']
        high_prev_close = (df['high'] - df['close'].shift(1)).abs()
        low_prev_close = (df['low'] - df['close'].shift(1)).abs()
        true_range = pd.concat([high_low, high_prev_close, low_prev_close], axis=1).max(axis=1)
        df['ATR'] = true_range.rolling(window=self.period).mean()
        return df

class LogReturnFeature(BaseFeature):
    def get_names(self) -> List[str]:
        return ['log_return']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        df['log_return'] = np.log(df['close'] / df['close'].shift(1))
        return df

class StochasticOscillatorFeature(BaseFeature):
    def __init__(self, config: Config):
        self.period = config.stochastic_period

    def get_names(self) -> List[str]:
        return ['stoch_k', 'stoch_d']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        low_min = df['low'].rolling(window=self.period).min()
        high_max = df['high'].rolling(window=self.period).max()
        df['stoch_k'] = 100 * ((df['close'] - low_min) / (high_max - low_min))
        df['stoch_d'] = df['stoch_k'].rolling(window=3).mean() 
        return df

class OBVFeature(BaseFeature):
    def get_names(self) -> List[str]:
        return ['OBV']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        if 'usd_volume' not in df.columns:
            # Fallback or assume caller ensures it. 
            # If we don't have usd_volume, OBV is usually on Volume.
            volume_col = 'volume' if 'volume' in df.columns else None
            if volume_col:
                 df['direction'] = np.where(df['close'].diff() >= 0, 1, -1)
                 df['OBV'] = (df[volume_col] * df['direction']).cumsum()
                 df.drop(columns=['direction'], inplace=True)
            return df
        
        df['direction'] = np.where(df['close'].diff() >= 0, 1, -1)
        df['OBV'] = (df['usd_volume'] * df['direction']).cumsum()
        df.drop(columns=['direction'], inplace=True)
        return df

class VolumeZScoreFeature(BaseFeature):
    def __init__(self, window: int = 20):
        self.window = window

    def get_names(self) -> List[str]:
        return [f'volume_zscore_{self.window}']

    def calculate(self, df: pd.DataFrame) -> pd.DataFrame:
        if 'usd_volume' in df.columns:
            vol_col = 'usd_volume'
        elif 'volume' in df.columns:
            vol_col = 'volume'
        else:
            return df
            
        vol_mean = df[vol_col].rolling(window=self.window).mean()
        vol_std = df[vol_col].rolling(window=self.window).std()
        df[f'volume_zscore_{self.window}'] = (df[vol_col] - vol_mean) / vol_std
        return df

class FeatureGenerator:
    def __init__(self, config: Config = Config()):
        self.config = config
        self.features: List[BaseFeature] = []
        self._add_default_features()

    def _add_default_features(self):
        """Add all features with default configuration."""
        self.add_feature(ReturnFeatures())
        self.add_feature(VolatilityFeatures())
        self.add_feature(VolumeFeatures())
        self.add_feature(PriceMAFeatures())
        self.add_feature(RSIFeature(self.config))
        self.add_feature(EMAFeature(self.config))
        self.add_feature(BollingerBandsFeature(self.config))
        self.add_feature(ATRFeature(self.config))
        self.add_feature(LogReturnFeature())
        self.add_feature(StochasticOscillatorFeature(self.config))
        self.add_feature(OBVFeature())
        self.add_feature(VolumeZScoreFeature())

    def add_feature(self, feature: BaseFeature) -> None:
        self.features.append(feature)

    def process_data(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        for feature in self.features:
            df = feature.calculate(df)
        return df

    def get_all_feature_names(self):
        all_feature_names = []
        for feature in self.features:
            all_feature_names.extend(feature.get_names())
        return all_feature_names
